##########################
# Coder: Aden Clymer
# Assignment PS03
# Date: 9/14/2023
##########################
import doctest
import random
import math

#Define a function named summarize_dice_rolls with two parameters.
#First parameter is a string composed of integers in the range representing a sequence of dice rolls 
#Second parameter is a single integer, n, in the range [1, 6]. 
#Function should return a string that does this:
#       '{times_n_was_rolled}/{total_rolls}'

def summarize_dice_rolls(numbers_rolled: str, n: int)->str:
    '''
    >>> summarize_dice_rolls('1', 6)
    '0/1'
    >>> summarize_dice_rolls('125636', 6)
    '2/6'
    '''
    #convert number needed to find into a string
    string_find_numb: str = str(n)
    #dice_number = str(n)
    times_n_was_rolled = 0
    #number how long the string is
    length = len(numbers_rolled)
    #run through each letter in the string and compare it to x
    i = 0
    for i in range(length):
        if string_find_numb in numbers_rolled[i:i+1]:
            times_n_was_rolled += 1
        i+=1
    #put that in string format
    ratio = str(times_n_was_rolled)+"/"+str(length)
    return ratio

#Define a function named how_many_primes with two parameters, both integers.
#The parameters represent a starting value and stopping value. 
#Calculate and return how many prime numbers exist within the range: [start, stop] 
#Assume positive starting and stopping values and starting value < stopping value.
def how_many_primes(starting_value: int, stopping_value: int)->int:
    '''
    >>> how_many_primes(1, 10)
    4
    >>> how_many_primes(10, 50)
    11
    '''
    #Ensure the numbers are inclusive
    #Starting value for how many prime numbers there initally
    prime_numbers: int = 0
    #divide everything by everything and if it's divisible by anything other than 1 and itself to get a number it's true    
    for num in range(starting_value, stopping_value+1):
        is_prime = True     #Cadet Jackson Buck suggested I utilize a boolean
        for i in range(2,num):
            test_if_prime = num % i 
            if test_if_prime == 0:
                is_prime = False
        if (is_prime == True):
            if num != 1:
                prime_numbers += 1
    return prime_numbers

#   Tn = Tn-1 + Tn-2 + Tn–3 ,
#   where T 0 = T1 = 0 and T2 = 1
#Define a function named closest_Tribonacci with one parameter, an integer, x.
#The function should determine and return the Tribonacci number that is closest to
#x, but strictly less than x.
     

def closest_Tribonacci(x: int)->int:
    '''
    >>> closest_Tribonacci(5)
    4
    >>> closest_Tribonacci(12)
    7
    '''
    #stop Tribonacci sequence at a number
    #initalize the numbers
    tn1 = 1
    tn2 = 0
    tn3 = 0
    tribi = tn1+tn2+tn3
    #continue until directly below it.
    while tribi < x:
        tn3 = tn2     #1
        tn2 = tn1     #1
        tn1 = tribi   #2
        tribi = tn1+tn2+tn3
        #print(tribi) checker
    return tn1
    

#Function named password_generator that takes a cadet email address as
#its only parameter 
#Returns a password generated by the following rules:
#   a. The password begins with the first two letters of the user’s last name
#       (both capitalized) and the last two letters of the user’s first name (both
#       lower case)
#   b. A sequence of digits obtained by adding the ASCII value (decimal
#       representation) of the first and last characters in the email address.
#       (Hint: review the ord() function, page 192)
#   c. The password concludes with a sequence of dollar signs ($) equal in
#       quantity to the number of times the letter 'e' appears in the cadet’s name.

def password_generator(email: str)->str:
    '''
    >>> password_generator('buzz.aldrin@westpoint.edu')
    'ALzz215'
    >>> password_generator('nadja.west@westpoint.edu')
    'WEja227$'
    '''
    #Condition A:
        #finding locations
    period_location: int = email.index(".")
    at_location: int = email.index("@")
        #Getting last name
    lastname_sequence: str = email[period_location+1:period_location+3]
        #capitalizing last name
    ln_firstletter: str = lastname_sequence[0:1].capitalize()
    ln_secondletter: str = lastname_sequence[1:2].capitalize()
        #combining last name
    capitalized_ln_sequence: str = ln_firstletter + ln_secondletter
    firstname_sequence: str = email[period_location-2:period_location]

    #Condition B:
    asci_first_value: int = ord(email[0])
    asci_last_value: int = ord(email[-1])
    total_acsi: int = asci_first_value+asci_last_value

    #Condition C:
    i = 0
    dollars = []
    for i in range(len(email[0:at_location])):
        if ('e' or 'E') in email[i:i+1]:
            dollars.append("$")
        i+=1
    total_dollars: str = "".join(dollars)

    put_together: str = capitalized_ln_sequence+firstname_sequence+str(total_acsi)+total_dollars

    return put_together

if __name__ == '__main__':
	doctest.testmod(verbose=True)